// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package dedicated

import (
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/request"
)

const opCreateDedicatedCluster = "CreateDedicatedCluster"

// CreateDedicatedClusterRequest generates a "ksc/request.Request" representing the
// client's request for the CreateDedicatedCluster operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateDedicatedCluster for more information on using the CreateDedicatedCluster
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateDedicatedClusterRequest method.
//    req, resp := client.CreateDedicatedClusterRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/CreateDedicatedCluster
func (c *Dedicated) CreateDedicatedClusterRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opCreateDedicatedCluster,
		HTTPMethod: "GET",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// CreateDedicatedCluster API operation for dedicated.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for dedicated's
// API operation CreateDedicatedCluster for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/CreateDedicatedCluster
func (c *Dedicated) CreateDedicatedCluster(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.CreateDedicatedClusterRequest(input)
	return out, req.Send()
}

// CreateDedicatedClusterWithContext is the same as CreateDedicatedCluster with the addition of
// the ability to pass a context and additional request options.
//
// See CreateDedicatedCluster for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Dedicated) CreateDedicatedClusterWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.CreateDedicatedClusterRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateDedicatedHosts = "CreateDedicatedHosts"

// CreateDedicatedHostsRequest generates a "ksc/request.Request" representing the
// client's request for the CreateDedicatedHosts operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateDedicatedHosts for more information on using the CreateDedicatedHosts
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateDedicatedHostsRequest method.
//    req, resp := client.CreateDedicatedHostsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/CreateDedicatedHosts
func (c *Dedicated) CreateDedicatedHostsRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opCreateDedicatedHosts,
		HTTPMethod: "GET",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// CreateDedicatedHosts API operation for dedicated.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for dedicated's
// API operation CreateDedicatedHosts for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/CreateDedicatedHosts
func (c *Dedicated) CreateDedicatedHosts(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.CreateDedicatedHostsRequest(input)
	return out, req.Send()
}

// CreateDedicatedHostsWithContext is the same as CreateDedicatedHosts with the addition of
// the ability to pass a context and additional request options.
//
// See CreateDedicatedHosts for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Dedicated) CreateDedicatedHostsWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.CreateDedicatedHostsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteDedicatedCluster = "DeleteDedicatedCluster"

// DeleteDedicatedClusterRequest generates a "ksc/request.Request" representing the
// client's request for the DeleteDedicatedCluster operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteDedicatedCluster for more information on using the DeleteDedicatedCluster
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteDedicatedClusterRequest method.
//    req, resp := client.DeleteDedicatedClusterRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/DeleteDedicatedCluster
func (c *Dedicated) DeleteDedicatedClusterRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opDeleteDedicatedCluster,
		HTTPMethod: "GET",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// DeleteDedicatedCluster API operation for dedicated.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for dedicated's
// API operation DeleteDedicatedCluster for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/DeleteDedicatedCluster
func (c *Dedicated) DeleteDedicatedCluster(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.DeleteDedicatedClusterRequest(input)
	return out, req.Send()
}

// DeleteDedicatedClusterWithContext is the same as DeleteDedicatedCluster with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteDedicatedCluster for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Dedicated) DeleteDedicatedClusterWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.DeleteDedicatedClusterRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteDedicatedHost = "DeleteDedicatedHost"

// DeleteDedicatedHostRequest generates a "ksc/request.Request" representing the
// client's request for the DeleteDedicatedHost operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteDedicatedHost for more information on using the DeleteDedicatedHost
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteDedicatedHostRequest method.
//    req, resp := client.DeleteDedicatedHostRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/DeleteDedicatedHost
func (c *Dedicated) DeleteDedicatedHostRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opDeleteDedicatedHost,
		HTTPMethod: "GET",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// DeleteDedicatedHost API operation for dedicated.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for dedicated's
// API operation DeleteDedicatedHost for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/DeleteDedicatedHost
func (c *Dedicated) DeleteDedicatedHost(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.DeleteDedicatedHostRequest(input)
	return out, req.Send()
}

// DeleteDedicatedHostWithContext is the same as DeleteDedicatedHost with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteDedicatedHost for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Dedicated) DeleteDedicatedHostWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.DeleteDedicatedHostRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeDedicatedCluster = "DescribeDedicatedCluster"

// DescribeDedicatedClusterRequest generates a "ksc/request.Request" representing the
// client's request for the DescribeDedicatedCluster operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeDedicatedCluster for more information on using the DescribeDedicatedCluster
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeDedicatedClusterRequest method.
//    req, resp := client.DescribeDedicatedClusterRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/DescribeDedicatedCluster
func (c *Dedicated) DescribeDedicatedClusterRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opDescribeDedicatedCluster,
		HTTPMethod: "GET",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// DescribeDedicatedCluster API operation for dedicated.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for dedicated's
// API operation DescribeDedicatedCluster for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/DescribeDedicatedCluster
func (c *Dedicated) DescribeDedicatedCluster(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.DescribeDedicatedClusterRequest(input)
	return out, req.Send()
}

// DescribeDedicatedClusterWithContext is the same as DescribeDedicatedCluster with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeDedicatedCluster for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Dedicated) DescribeDedicatedClusterWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.DescribeDedicatedClusterRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeDedicatedHosts = "DescribeDedicatedHosts"

// DescribeDedicatedHostsRequest generates a "ksc/request.Request" representing the
// client's request for the DescribeDedicatedHosts operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeDedicatedHosts for more information on using the DescribeDedicatedHosts
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeDedicatedHostsRequest method.
//    req, resp := client.DescribeDedicatedHostsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/DescribeDedicatedHosts
func (c *Dedicated) DescribeDedicatedHostsRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opDescribeDedicatedHosts,
		HTTPMethod: "GET",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// DescribeDedicatedHosts API operation for dedicated.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for dedicated's
// API operation DescribeDedicatedHosts for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/DescribeDedicatedHosts
func (c *Dedicated) DescribeDedicatedHosts(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.DescribeDedicatedHostsRequest(input)
	return out, req.Send()
}

// DescribeDedicatedHostsWithContext is the same as DescribeDedicatedHosts with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeDedicatedHosts for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Dedicated) DescribeDedicatedHostsWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.DescribeDedicatedHostsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opHostMigrate = "DedicatedHostMigrate"

// HostMigrateRequest generates a "ksc/request.Request" representing the
// client's request for the HostMigrate operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See HostMigrate for more information on using the HostMigrate
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the HostMigrateRequest method.
//    req, resp := client.HostMigrateRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/HostMigrate
func (c *Dedicated) HostMigrateRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opHostMigrate,
		HTTPMethod: "GET",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// HostMigrate API operation for dedicated.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for dedicated's
// API operation HostMigrate for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/HostMigrate
func (c *Dedicated) HostMigrate(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.HostMigrateRequest(input)
	return out, req.Send()
}

// HostMigrateWithContext is the same as HostMigrate with the addition of
// the ability to pass a context and additional request options.
//
// See HostMigrate for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Dedicated) HostMigrateWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.HostMigrateRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opInstanceMigrate = "InstanceMigrate"

// InstanceMigrateRequest generates a "ksc/request.Request" representing the
// client's request for the InstanceMigrate operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See InstanceMigrate for more information on using the InstanceMigrate
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the InstanceMigrateRequest method.
//    req, resp := client.InstanceMigrateRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/InstanceMigrate
func (c *Dedicated) InstanceMigrateRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opInstanceMigrate,
		HTTPMethod: "GET",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// InstanceMigrate API operation for dedicated.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for dedicated's
// API operation InstanceMigrate for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/InstanceMigrate
func (c *Dedicated) InstanceMigrate(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.InstanceMigrateRequest(input)
	return out, req.Send()
}

// InstanceMigrateWithContext is the same as InstanceMigrate with the addition of
// the ability to pass a context and additional request options.
//
// See InstanceMigrate for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Dedicated) InstanceMigrateWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.InstanceMigrateRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opModifyDedicatedClusterName = "ModifyDedicatedClusterName"

// ModifyDedicatedClusterNameRequest generates a "ksc/request.Request" representing the
// client's request for the ModifyDedicatedClusterName operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ModifyDedicatedClusterName for more information on using the ModifyDedicatedClusterName
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ModifyDedicatedClusterNameRequest method.
//    req, resp := client.ModifyDedicatedClusterNameRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/ModifyDedicatedClusterName
func (c *Dedicated) ModifyDedicatedClusterNameRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opModifyDedicatedClusterName,
		HTTPMethod: "GET",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// ModifyDedicatedClusterName API operation for dedicated.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for dedicated's
// API operation ModifyDedicatedClusterName for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/ModifyDedicatedClusterName
func (c *Dedicated) ModifyDedicatedClusterName(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.ModifyDedicatedClusterNameRequest(input)
	return out, req.Send()
}

// ModifyDedicatedClusterNameWithContext is the same as ModifyDedicatedClusterName with the addition of
// the ability to pass a context and additional request options.
//
// See ModifyDedicatedClusterName for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Dedicated) ModifyDedicatedClusterNameWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.ModifyDedicatedClusterNameRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opRenameDedicatedHost = "RenameDedicatedHost"

// RenameDedicatedHostRequest generates a "ksc/request.Request" representing the
// client's request for the RenameDedicatedHost operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See RenameDedicatedHost for more information on using the RenameDedicatedHost
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the RenameDedicatedHostRequest method.
//    req, resp := client.RenameDedicatedHostRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/RenameDedicatedHost
func (c *Dedicated) RenameDedicatedHostRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opRenameDedicatedHost,
		HTTPMethod: "GET",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// RenameDedicatedHost API operation for dedicated.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for dedicated's
// API operation RenameDedicatedHost for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/RenameDedicatedHost
func (c *Dedicated) RenameDedicatedHost(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.RenameDedicatedHostRequest(input)
	return out, req.Send()
}

// RenameDedicatedHostWithContext is the same as RenameDedicatedHost with the addition of
// the ability to pass a context and additional request options.
//
// See RenameDedicatedHost for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Dedicated) RenameDedicatedHostWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.RenameDedicatedHostRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opRunInstances = "RunInstances"

// RunInstancesRequest generates a "ksc/request.Request" representing the
// client's request for the RunInstances operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See RunInstances for more information on using the RunInstances
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the RunInstancesRequest method.
//    req, resp := client.RunInstancesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/RunInstances
func (c *Dedicated) RunInstancesRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opRunInstances,
		HTTPMethod: "GET",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// RunInstances API operation for dedicated.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for dedicated's
// API operation RunInstances for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/RunInstances
func (c *Dedicated) RunInstances(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.RunInstancesRequest(input)
	return out, req.Send()
}

// RunInstancesWithContext is the same as RunInstances with the addition of
// the ability to pass a context and additional request options.
//
// See RunInstances for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Dedicated) RunInstancesWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.RunInstancesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opSetvCPU = "SetvCPU"

// SetvCPURequest generates a "ksc/request.Request" representing the
// client's request for the SetvCPU operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See SetvCPU for more information on using the SetvCPU
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the SetvCPURequest method.
//    req, resp := client.SetvCPURequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/SetvCPU
func (c *Dedicated) SetvCPURequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opSetvCPU,
		HTTPMethod: "GET",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// SetvCPU API operation for dedicated.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for dedicated's
// API operation SetvCPU for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/kec-2016-03-04/SetvCPU
func (c *Dedicated) SetvCPU(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.SetvCPURequest(input)
	return out, req.Send()
}

// SetvCPUWithContext is the same as SetvCPU with the addition of
// the ability to pass a context and additional request options.
//
// See SetvCPU for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Dedicated) SetvCPUWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.SetvCPURequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}
